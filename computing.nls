;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                         COMPUTING PROCEDURES                         ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to compute-values
  set unemployement_level count persons with [not employed]
  set vacancy_level count companies with [not job_filled]
  set unemployement_rate unemployement_level / nb_of_persons
  set vacancy_rate vacancy_level / nb_of_persons
  
  update-convergence
  update-average-job-duration
  update-average-unemployement-duration
  update-average-vacant-duration
  update-market-friction
  update-indicators
end

to update-average-job-duration
  ask persons with [employed] [
    set job-time ( job-time + 1 )
  ]
  let job-sum sum [job-time] of persons
  ifelse nb_of_persons != unemployement_level [
    set average-job-duration ( job-sum / (nb_of_persons - unemployement_level) )
  ]
  [
    set average-job-duration 0
  ]
end

to update-average-unemployement-duration
  ask persons with [not employed] [
    set unemployement-time ( unemployement-time + 1 )
  ]
  let unemployement-sum sum [unemployement-time] of persons
  ifelse unemployement_level != 0 [
    set average-unemployement-duration ( unemployement-sum / unemployement_level)
  ]
  [
    set average-unemployement-duration 0
  ]
end

to update-average-vacant-duration
  ask companies with [not job_filled] [
    set vacant-time ( vacant-time + 1 )
  ]
  let vacant-sum sum [vacant-time] of companies
  if vacancy_level != 0 [
    set average-vacant-duration ( vacant-sum / vacancy_level)
  ]
end

to update-market-friction
  set friction nb-failed-matching / (min list nb_of_pairs_considered vacancy_level unemployement_level])
  set nb-failed-matching 0
end

;procédure qui met en mémoire les min(nb-of-step-remembered, ticks) derniers éléments en mémoire dans last-values-unemployement
to stock-last-values
  let temp fput unemployement_rate last-values-unemployement ;push to the beginning of the list
  if ticks >= nb-of-step-remembered [
    set temp but-last temp ;pop last element if list is of size nb-of-step-remembered
  ]
  set last-values-unemployement temp
  
  let temp2 fput average-unemployement-duration last-values-indic2 ;push to the beginning of the list
  if ticks >= nb-of-step-remembered [
    set temp2 but-last temp2 ;pop last element if list is of size nb-of-step-remembered
  ]
  set last-values-indic2 temp2
  
  let temp3 fput average-job-duration last-values-indic3 ;push to the beginning of the list
  if ticks >= nb-of-step-remembered [
    set temp3 but-last temp3 ;pop last element if list is of size nb-of-step-remembered
  ]
  set last-values-indic3 temp3
  
  let temp4 fput average-vacant-duration last-values-indic4 ;push to the beginning of the list
  if ticks >= nb-of-step-remembered [
    set temp4 but-last temp4 ;pop last element if list is of size nb-of-step-remembered
  ]
  set last-values-indic4 temp4
  
    let temp5 fput friction last-values-indic5 ;push to the beginning of the list
  if ticks >= nb-of-step-remembered [
    set temp5 but-last temp5 ;pop last element if list is of size nb-of-step-remembered
  ]
  set last-values-indic5 temp5
end

; procédure qui surveille la convergence du système et met à jour la valeur du bolléen CONVERGENCE si il y a convergence
; critère : unemployement-level
; on calcul une moyenne glissante et on regarde si le nouveau résultat est proche ou non
to update-convergence
  if ticks > nb-of-step-remembered [
    set moving-average mean last-values-unemployement
    
    if ( abs(moving-average - unemployement_rate) ) < moving-average * (converge-criteria / 100) [
      set convergence TRUE
      type "The market has converged at tick n° :" type ticks type "\n"
    ]
  ] 
end

to update-indicators
  if ticks > nb-of-step-remembered [
    set indic-2 round mean last-values-indic2
    set indic-3 round mean last-values-indic3
    set indic-4 round mean last-values-indic4
    set indic-5 mean last-values-indic5
  ]
end
