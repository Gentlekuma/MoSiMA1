;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                         COMPUTING PROCEDURES                         ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to compute-values
  set unemployement_level count persons with [not employed]
  set vacancy_level count companies with [not job_filled]
  set unemployement_rate unemployement_level / nb_of_persons
  set vacancy_rate vacancy_level / nb_of_persons
  
  update-convergence
  update-average-job-duration
  update-average-unemployement-duration
  update-average-vacant-duration
  update-market-friction
end

to update-average-job-duration
  ask persons with [employed] [
    set job-time ( job-time + 1 )
  ]
  let job-sum sum [job-time] of persons
  set average-job-duration ( job-sum / (nb_of_persons - unemployement_level) )
end

to update-average-unemployement-duration
  ask persons with [not employed] [
    set unemployement-time ( unemployement-time + 1 )
  ]
  let unemployement-sum sum [unemployement-time] of persons
  set average-unemployement-duration ( unemployement-sum / unemployement_level)
end

to update-average-vacant-duration
  ask companies with [not job_filled] [
    set vacant-time ( vacant-time + 1 )
  ]
  let vacant-sum sum [vacant-time] of companies
  set average-vacant-duration ( vacant-sum / vacancy_level)
end

to update-market-friction
  set friction nb-failed-matching / nb_of_pairs_considered
  set nb-failed-matching 0
end

;procédure qui met en mémoire les min(nb-of-step-remembered, ticks) derniers éléments en mémoire dans last-values-unemployement
to stock-last-values
  let temp fput unemployement_rate last-values-unemployement ;push to the beginning of the list
  if ticks >= nb-of-step-remembered [
    set temp but-last temp ;pop last element if list is of size nb-of-step-remembered
  ]
  set last-values-unemployement temp
end

; procédure qui surveille la convergence du système et met à jour la valeur du bolléen CONVERGENCE si il y a convergence
; critère : unemployement-level
; on calcul une moyenne glissante et on regarde si le nouveau résultat est proche ou non
to update-convergence
  if ticks > nb-of-step-remembered [
    set moving-average mean last-values-unemployement
    
    if ( abs(moving-average - unemployement_rate) ) < moving-average * (converge-criteria / 100) [
      set convergence TRUE
      type "The market has converged at tick n° :" type ticks type "\n"
    ]
  ] 
end
